<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
    <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <title>Schematron Exercise 2</title>
        <link rel="stylesheet" type="text/css" href="explain.css"/>
    </head>
    <body>
        <!--#include virtual="top.html" -->
        <section title="exerciseName"><h1><span class="banner">Schematron Exercise 2</span></h1></section>
        <a href="http://schematron.com"><img src="schematronLogo.png" alt="Schematroll, the Schematron mascot"/></a><span class="smaller">Meet Schematroll, the <a href="http://schematron.com/">Schematron</a> mascot! Schematroll is a cross between a <a href="http://members.optusnet.com.au/bilbies/About_Bilbies.htm">bilby</a> and a <a href="http://www.iucnredlist.org/details/2783/0">bettong</a>.</span>
        <section title="preliminaries">
            <h3>Preliminaries</h3>
            <p>To work on this assignment, you will need to to find and do the following:</p>
            <ul>
                <li><strong>Information resources at the ready:</strong> 
                    Review <a href="http://newtfire.org/dh/explainSchematron.html">our Schematron tutorial</a>, and read more about the XPath functions and syntax we describe below either on the web (see w3Schools’ <a href="http://www.w3schools.com/xsl/xsl_functions.asp">“XSLT, XPath, and XQuery Functions”</a>, Obdurodon’s <a href="http://dh.obdurodon.org/functions.xhtml">“The XPath Functions We Use the Most”</a>) or through offline searching with the index of the Michael Kay book. You also want to read <a href="explainSchematronIdRefs.html">our tutorial on validating id attributes</a>.</li>  
                    
                <li><strong>XML file to test:</strong> Right-click to save this TEI file locally and open it in &lt;oXygen/&gt;: <a href="si-ADD-MRMsample.xml"><strong>Sample for Digital Mitford Site Index</strong></a>. You will need to associate your Schematron file with this document <strong>in addition to</strong> the currently associated TEI schema lines.</li>
                    
                <li>Open a new Schematron document in &lt;oXygen/&gt; by going to <strong>File → New</strong> and typing “Schematron” in the “Type filter text” box, or by going to <strong>File → New → New Document → (scroll to Schematron in the alphabetized list) → Schematron</strong>. Once opened, you will keep the default xml line at the top, but you will delete everything from <code>&lt;sch:schema&gt;</code> down. To write Schematron rules for a document in the TEI namespace, you will then replace this with:
            <pre>&lt;schema xmlns:sch="http://purl.oclc.org/dsdl/schematron" queryBinding="xslt2"
    xmlns:sqf="http://www.schematron-quickfix.com/validator/process"
    xmlns="http://purl.oclc.org/dsdl/schematron"&gt;
        &lt;ns uri="http://www.tei-c.org/ns/1.0" prefix="tei"/&gt;
        
    &lt;/schema&gt;</pre></li>
                <li>Write your Schematron patterns <strong>inside</strong> the <code>&lt;/schema&gt;</code> root element.</li>
                <li><strong>Important:</strong> You must use the <code>tei:</code> prefix before each of your elements since we are working with a document in the TEI namespace; otherwise none of your schema rules involving elements will fire! Remember that we do <strong>not</strong> use that prefix before attributes because attributes are in no namespace.</li>
            </ul>
            
        </section>
        <section title="analysisOfTask">
            <h3>Analysis of the task</h3>
            <section title="goal">
                <h4>The goal:</h4>
                <p>The Digital Mitford project is working on a collection of prosopography data, that is, a record of people, places, organizations, published works, and other named entities relevant to British author Mary Russell Mitford’s world in the nineteenth century. After some years of collaborative research the collection (which we call our <q>Site Index</q>) contains thousands of entries, all contributed in batches by members of the editing team in the course of their research. It’s common for our editors to make typographical errors as they enter details about historical people in particular, since these entries can be especially complicated! Your task is to write a helpful Schematron file to guide the editors in their process, flag errors if they reverse date ranges like birth and death dates, check for white space errors and other common problems, and check to see that the referencing of <code>@xml:id</code> attributes is correct. We hope that learning these things will give you ideas for writing Schematron to guide your own projects.</p>
                <p>As you work on the rules below, think about how to group them logically into related <code>pattern</code> elements. You can use an <code>@id</code> on <code>pattern</code> elements to help label them and organize your work. Also, be sure to associate your Schematron file with the XML file you are testing <em>as soon as you write your first rule</em> so you can test it to make sure it is working.</p>
             
            </section>
            <section title="rules">
                <h4>Rules to write and test</h4>
                
                <ol>  
                    <li>We want to close up extra white spaces that our editors inevitably type at the start of their elements. Write a Schematron rule that checks for leading white space inside any element. (That is, raise a warning when an element <em>starts with</em> a white space.) Hint: you may want to look at the <code>starts-with()</code> function, one of the family related to <code>contains()</code>.</li>
                    <li>We are keeping track of the sex of each person in the historical persons lists so that we can study the proportion of males to females in Mitford’s social network. To mark this, we are using the <code>@sex</code> attribute on the <code>person</code> element. There are <a href="https://en.wikipedia.org/wiki/ISO/IEC_5218">four standard ISO codes for sex</a> that we have decided to use: 1 (for males), 2 (for females), 0 (for unknown), and 9 (for not applicable). Though these standard code numbers have understandably provoked controversy, our team decided that the simple set of numbers was sufficient for the nineteenth-century context of our project. But our editors sometimes forget to code or miscode the @sex attribute. They might also forget to apply the standard <code>@xml:id</code> to that element. To check for these problems, write and test two Schematron rules:
                    <ul>
                        <li>A rule that checks to makes sure the <code>@sex</code> and <code>@xml:id</code> elements are present on the <code>person</code> element, and</li>
                        <li>A rule that establishes the permitted values of the <code>@sex</code> attribute. Note: the format for coding a series of permitted attribute values is very similar to the way we do it in Relax-NG, with a comma-separated list that we wrap in parentheses, thus:
                        <pre>
                            &lt;rule context="tei:element"&gt;
                                &lt;assert test=<code>"@attName = ('val1', 'val2', 'val3')"</code>&gt;
                                Your message here&lt;/assert&gt;
                             &lt;/rule&gt;   
                        </pre></li>
                    </ul></li>
                    <li>While you’re working on Schematron tests for the <code>person</code> element, we want to check the way its <code><dfn>@xml:id</dfn></code> is written. In our project when a historical person is given a unique identifier, that <code>@xml:id</code> value is supposed to begin with the most distinctive part of the person’s name, their <em>last</em> name. Since we code the <code>surname</code> element as a descendant of <code>person</code>, you may write a Schematron rule that tests whether the <code>@xml:id</code> <em>starts with</em> the contents of the surname element. There is one complication mainly for women in the list: they frequently have two different kinds of surname, a <code>&lt;surname type="paternal"&gt;</code> and a <code>&lt;surname type="married"&gt;</code>, and the <code>@xml:id</code> could start with either one (depending on how Mitford knew the person). Write a rule to test if the @xml:id on each person element starts with <em>either</em> of these types of surname, and check to see if your rule is working.</li>
                    <li>Sometimes our editors don’t capitalize proper names! Check that all TEI <code>forename</code>, <code>surname</code>, and <code>placeName</code> elements, as well as any <code>persName</code> elements that hold text and do not wrap around forename and surname elements start with capital letters (you can do that with one rule).</li>
                   <!--ebb: removing to shorten the assignment <li>Take a look at the <code>occupation</code> element. This is supposed to contain a single word, but sometimes our editors type in two or more words. Write a Schematron rule that flags occupation elements that are more than one word! (Hint: For this we used the <code>matches()</code> function.)</li>-->
                    <li>Now let’s work on the dates. Notice how we have paired <code>@from</code> and <code>@to</code> attributes in pairs to indicate a date range. Write a Schematron rule to check that the dates in a pair of @from and @to attributes are plausible: No <code>@from</code> should be later than an <code>@to</code>.(Note: Applying <code>xs:date()</code> won’t work here because these are entered simply as four-digit years and won’t be recognized as ISO dates.)</li>
                    <li>Similarly, all death dates need to be later than birth dates. Write a Schematron rule to flag when these dates don’t make sense. Note: this is a little more complicated than the previous rule you wrote because some dates are given as full ISO years (<code>yyyy-mm-dd</code>) and others are only partial and won't translate with <code>xs:date()</code>. We dealt with this by using the <code>tokenize()</code> function to isolate the year as the piece that we really need to look at, that is, the four-digit year that sits in front of the first hyphen. To reliably capture this piece, write the <code>tokenize()</code> function to break the attribute values in pieces around hyphens (<q>tokenize on the hyphen</q>) and write a position predicate to grab the <em>first</em> of the tokens. (Note: Even if the date value lacks any hyphens and only contains a year, this will still return that year since the token just won’t break off!)</li>
                    
                    <li>For our last two rules, you will need to consult our guide on <a href="explainSchematronIdRefs.html">Coding with Unique Identifiers and Testing Them with Schematron</a>. First of all, is very important for our site index file that <code>@xml:ids</code> must not contain white spaces and must not begin with a leading hashtag (<code>#</code>), since (our guide explains) the hashtag is reserved for <code>@ref</code> attributes that <em>point to</em> <code>@xml:ids</code>. Write Schematron rule(s) to test and flag errors here.</li>
                    
                    
                    <li>Finally, carefully following <a href="explainSchematronIdRefs.html">our guide on testing unique identifiers</a>, test to see whether the <code>@ref</code> and <code>@resp</code> attribute values, <em>following their hashtags</em>, actually matches up to a defined <code>@xml:id</code> in this file <em>or</em> in the
                        Digital Mitford Site Index at <code>http://digitalmitford.org/si.xml</code>. (Note that this rule will also ensure that these values actually begin with a hashtag!) Following our guide, you will learn how to write a <code>let</code> statement to define a variable that points to another file’s <code>@xml:ids</code>, and then <em>refer</em> to that variable in your Schematron test. Also, it is perfectly legal in our project for there to be <em>multiple</em> values on an <code>@ref</code> or <code>@resp</code>, separated by white space, just as you see in our guide, so you should follow our lead to adapt our code there.
</li>
                    <li><strong>Bonus Challenge:</strong> We need a more sophisticated way than we used in number 4 to check the way people type out full names in the <code>persName</code> elements. Can we test for errors like these?
                        <pre>Dorothy wordsworth</pre> 
                        or
                        <pre>Percy bysshe Shelley</pre>
                        Of course we can, by adapting the <code>tokenize()</code> we have been using here to break on white space, and to test <strong>each</strong> token in turn to see if it is capitalized. You can do this by applying the <code>for $i in (sequence) return …</code> (or <q><strong>for-loop</strong></q> XPath feature) so we can walk through each token in the full sequence. To see how to write the code, consult our <a href="explainSchematronIdRefs.html">our guide on testing unique identifiers</a>: Look at our <code>let</code> statement, defining a variable containing a sequence of tokens, and then consider how we processed each one in turn in our <code>assert @test</code>. Can you adapt that code to tokenize the parts of a name, and test to see if each part is capitalized? Write your Schematron rule!       
                    </li>  
                    
             
             </ol>
                
                <section title="uploading">
                    <h3>Submission</h3>
                    <p>Upload your completed Schematron schema AND the si-Add-MRMsample.xml file <strong>with your Schematron associated</strong> to Courseweb, and follow our <a href="explainFileNames.html">standard filenaming conventions for homework assignments uploaded to Courseweb</a>.</p>
                </section>
            </section>
        </section>
    
</body></html>